# Задание 3. Найдите ошибки


## Задание

**Дан исходный код приложения, в котором есть ошибки. Одни ошибки — стилистические, а другие не позволят даже запустить приложение. Вам нужно найти все ошибки и исправить их.**

Тестовое приложение — это плагин VS Code для удобного прототипирования интерфейсов с помощью дизайн-системы из первого задания. Вы можете описать в файле `.json` блоки, из которых состоит интерфейс. Плагин добавляет превью (1) и линтер (2) для структуры блоков.

## Выполнение задания

### Этап 1 

Устанавливаем зависимости с помощью `npm i` и пробуем запустить приложение нажатием `F5`

После запуска открывается новое окно VS Code, однако скрипт server.ts показывает две проблемы:
* `Argument of type '(params: InitializeParams) => { capabilities: { textDocumentSync: string; }; }' is not assignable to parameter of type 'RequestHandler<InitializeParams, InitializeResult, InitializeError>'.`

* `Property 'loc' does not exist on type 'AstIdentifier'.`

Первая проблема происходит на этапе инициализации сервера. Читаем сообщение об ошибке, обращаем внимание на строки `Type '{ textDocumentSync: string; }' is not assignable to type 'ServerCapabilities'.` и `Type 'string' is not assignable to type '0 | TextDocumentSyncOptions | 1 | 2 | undefined'`. Отсюда следует, что параметру `textDocumentSync` нельзя присвоить строку. Если навести на него мышку, всплывёт подсказка с документацией, где описано, что это за параметр и какие данные можно ему присвоить. Видим, что `textDocumentSync` определяет, как синхронизуются текстовые документы и является либо объектом `TextDocumentSyncOptions`, либо числом `TextDocumentSyncKind`. Попробуем указать тип `TextDocumentSyncKind`. Открываем документацию `TextDocumentSyncKind`, там описано три типа синхронизации: `None`, `Full` и `Incremental`. Им соответствуют числа от 0 до 2. Судя по описанию типов, нам подходит `Full = 1`, поскольку изначально мы пытались присвоить `textDocumentSync` строку `'always'`, а вариант `Full` означает, что документы всегда синхронизируются путём отправки всего содержимого. Исправляем первоначальный вариант на `textDocumentSync: 1`.

Вторая ошибка связана с тем, что `property.key` не содержит свойства `loc`. `property` соответствует интерфейсу `AstProperty` модуля `json-to-ast`. Откроем данный модуль, чтобы посмотреть, какие свойства есть у `AstProperty`. Видим, что надо указавать `property.loc`, вместо `property.key.loc`. Исправляем ошибку.

### Этап 2

Открываем приложение и пробуем открыть превью для файла `index.json` из первого задания. Вместо структуры блоков видим только надпись `{{content}}`.

В файле `extension.ts` находим функциональное выражение `updateContent`, в котором сгенерированная страница вставляется в превью. Обращаем внимание на регулярное выражение `/{{\s+(\w+)\s+}}/g`, при помощи которого осуществляется замена. Видно, что в местах, куда должна осуществляться вставка в `index.html` из папки `preview` пропущены пробелы, добавляем их.

### Этап 3.

Снова пытаемся открыть превью для `index.json`, на этот раз вообще ничего не показывается. Однако надпись `{{content}}` исчезла, следовательно регулярное выражение теперь работает.

Тут можно вспомнить, что интерфейсные блоки не содержат никакого контента, а их внешний вид полностью определяется добавленными стилями. Следовательно проблема может быть в том, что к блокам неправильно применяются стили.

Открываем `style.css` в папке `preview` и находим ошибку - стили добавляются не к тегу `div`, а к несуществующему классу `.div`. Убираем лишние точки.

### Этап 4.

Отображение превью до сих пор не работает. Остаётся ещё несколько непроверенных мест, где могут оставаться ошибки. Это чтение данных из json, генерация html-разметки и получение `URI` корневой папки приложения - `mediaPath`, который используется в html для подключения внешних файлов.

Корректность последнего проверить проще всего - просто добавляем вручную стили из `style.css` на страницу `index.html`, используя тег `<style>`. После этого отображение блоков появляется, следовательно проблема именно с `mediaPath`.

Открываем `extension.ts` и ищем место, где определяется `mediaPath`, который подставляется в html. Обнаруживаем, что это происходит в `updateContent` с помощью вызова `getMediaPath(context)`. Воспользовавшись выводом в консоль, видим, что `getMediaPath(context)` возвращает `URI` с измененной схемой обращения к ресурсу - `resource`. Смотрим `getMediaPath` и видим, что схема в `URI` заменяется на `resource` с помощью метода `with`.

Отображение веб-содержимого на вкладке VS Code осуществляется при помощи `Webview API`. Ищем в поисковике, какая `URI` схема подходит для загрузки локального контента в `Webview`. [Находим это место в документации](https://code.visualstudio.com/api/extension-guides/webview#loading-local-content). Там написано, что `Webview` по умолчанию не имеет доступа к локальным файлам. Чтобы получить доступ, необходимо изменить `URI` при помощи метода `Webview.asWebviewUri`. Поскольку данный метод просто меняет схему на `vscode-resource`, мы можем заменить `.with({ scheme: "resource"})` на `.with({ scheme: "vscode-resource"})` в `getMediaPath`. После этого отображение превью интерфейса наконец заработает.

### Этап 5.

Проверим работу линтера. Включаем его в настройках VS Code и начинаем редактировать `.json` с нарушением правил, которые проверяет линтер. Сообщения об ошибках не появляются.

Внимательно смотрим файл `linter.ts`. Видим, что в функции `makeLint` создаётся пустой массив `errors`, в который по мере хождения по абстрактному синтаксическому дереву json-файла должны добавляться ошибки, возвращаемые функциями `validateProperty` и `validateObject`. Находим ошибку, состоящую в том, что вместо метода `errors.push(...[foundErrors])` используется `errors.concat(...[foundErrors])`. Первый добавляет найденные ошибки в конец массива `errors` и возвращает новую длину, а второй возвращает массив, соединенный из `errors` и `foundErrors`, не изменяя `errors`. А `makeLint` возвращает именно `errors`, поэтому до сих пор она возвращала пустой массив. Исправляем ошибку.

### Этап 6.

Линтер по-прежнему не подсвечивает ошибки. Найдём место в коде, где используется функция `makeLint`. Находим функцию `validateTextDocument` в `server.ts`. Проверяя её, находим строку `const json = textDocument.uri;`. Сейчас константе `json` присваивается `URI` проверяемого файла, а не его содержимое. Исправляем на `const json = textDocument.getText();`.

После этого линтер работает.

### Этап 7.

Обнаруживаем проблему с типами сообщений линтера - в настройках указываем `Error`, а сообщения показываются как `Information`. Находим соответствующую ошибку в конструкции `switch` функции `GetSeverity` файла `server.ts`. Для случая `Severity.Error` функция возвращала `DiagnosticSeverity.Information`. Исправляем ошибку, проблема исчезает.

### Этап 8.

Теперь подправим codestyle. В приложение уже был включём линтер TSLint и конфиг `tsling.json` с несколькими правилами для него. Расширим эти правила, воспользовавшись пресетом `"tslint:recommended"`. Некоторые правила из пресета, которые на мой взгляд не делают codestyle лучше, я отключил.

С помощью линтера был исправлен ряд недочётов в файлах `configuration.ts`, `extension.ts`, `linter.ts`, `server.ts` и `jsonMain`. В их числе:
- неиспользованные переменные
- разный стиль кавычек
- больше 1 пустой строки между блоками кода
- лишние пробелы
- объявление неизменяемых переменных с помощью let, а не const

### Дополнительные исправления недочётов

Просмотрев ещё раз файлы, я нашёл ещё несколько моментов, которые можно исправить:

#### `extension.ts`
- функция `initPreviewPanel` - в `panel` запишем объектный литерал с одним свойством в одну строчку;
- блок `catch` в `updateContent` пуст. Добавим вывод ошибки в консоль.
- функция `openPreview` -  `else` на одной строке с `if`. Исправил.
- уберём вывод в консоль сообщения `Congratulations, your extension is now active!`.

#### `linter.ts`
- функцию `parseJson` можно сделать стрелочной.

#### `server.ts`
- в функции `validateTextDocument` получение списка выявленных ошибок `diagnostics` реализовано слишком сложно для восприятия. Чтобы сделать код более удобочитаемым, избавляемся от метода `reduce` и используем вместо него `forEach`. Слегка подформатируем код. В последней строчке, где выполняется отправка диагностики, убираем проверку условия `if (diagnostics.length)`, поскольку из-за него в настройках типа сообщений теперь перестаёт правильно работать вариант `'None'`.
<details>
  <summary>Было</summary>

  ```javescript
  const diagnostics: Diagnostic[] = makeLint(
        json,
        validateProperty,
        validateObject
    ).reduce(
        (
            list: Diagnostic[],
            problem: LinterProblem<RuleKeys>
        ): Diagnostic[] => {
            const severity = GetSeverity(problem.key);

            if (severity) {
                const message = GetMessage(problem.key);

                const diagnostic: Diagnostic = {
                    range: {
                        start: textDocument.positionAt(
                            problem.loc.start.offset
                        ),
                        end: textDocument.positionAt(problem.loc.end.offset)
                    },
                    severity,
                    message,
                    source
                };

                list.push(diagnostic);
            }

            return list;
        },
        []
    );
    
    if (diagnostics.length) {
        conn.sendDiagnostics({ uri: textDocument.uri, diagnostics });
    }
  ```
</details>

<details>
  <summary>Стало</summary>

  ```javescript
  const problems = makeLint(json, validateProperty, validateObject);
  const diagnostics: Diagnostic[] = [];

  problems.forEach((problem: LinterProblem<RuleKeys>) => {
        const severity = GetSeverity(problem.key);

        if (severity) {
            const message = GetMessage(problem.key);

            const diagnostic: Diagnostic = {
                range: {
                    start: textDocument.positionAt(problem.loc.start.offset),
                    end: textDocument.positionAt(problem.loc.end.offset)
                },
                severity,
                message,
                source
            };

            diagnostics.push(diagnostic);
        }
  });

  conn.sendDiagnostics({ uri: textDocument.uri, diagnostics });
  ```
</details>


### Подключение стилей и линтера из первых двух заданий

**Для подключения стилей отображения блоков и линтера создана новая ветка - `custom-styles-and-linter`**

1. Сперва реализуем отображение превью с помощью вёрстки и JS из первого задания. Для этого просто поместим собранные ранее билды `style.css` и `script.js` в папку `preview` и подключим скрипт `script.js` в `index.html`. Проверяем, всё работает корректно.

2. Теперь добавим линтер.

- Сперва удалим файлы старого линтера из папок `src` и `out`.
- Поместим файл с линтером из второго задания в `lib/linter/`.
- Новый линтер создаёт функцию `lint()` в глобальной области. Создадим declaration file `global.d.ts` в папке `src`, где объявим функцию вместе с типами.
- Импортируем линтер в `server.ts` с помощью метода `require`.
- Исправляем функцию `validateTextDocument` так, чтобы новый линтер заработал.
- Удаляем ненужные теперь функции и импорты: `GetMessage` и `json-to-ast`.
- Исправляем файл `configuration.ts`, заменив старые правила линтинга на новые.
- Чтобы правила заработали, изменим также функцию `GetSeverity` в `server.ts`.
- Наконец, добавим в настройки возможность выбрать тип сообщения для каждого, из правил. Для этого внесём соответствующие исправления в `package.json`

Проверяем, линтер работает как надо.


### Итоги

Всё сделано.